\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Informe TP0 organizacion de compus}
\author{Bárbara Mesones Miret,  Sebastián D'Alessandro Szymanowski, Nestor Huallpa }
\date{Septiembre 2018}

\begin{document}

\maketitle

\section{Introducción}

El presente informe corresponde al primer trabajo práctico grupal "TP0" de la materia organización de computadoras.
A continuación la presentación del enunciado y luego la resolución del mismo.

\section{Enunciado}


\subsection{Objetivos}
Familiarizarse con las herramientas de software que usaremos en los siguien-
tes trabajos, implementando un programa (y su correspondiente documenta-
ción) que resuelva el problema piloto que presentaremos más abajo.

\subsection{Alcance}
Este trabajo práctico es de elaboración grupal, evaluación individual, y de
carácter obligatorio para todos alumnos del curso.

\subsection{Requisitos}
El trabajo deberá ser entregado personalmente, en la fecha estipulada, con
una carátula que contenga los datos completos de todos los integrantes.
Además, es necesario que el trabajo práctico incluya (entre otras cosas, ver
sección 6), la presentación de los resultados obtenidos explicando, cuando corres-
ponda, con fundamentos reales, las causas o razones de cada resultado obtenido.
El informe deberá respetar el modelo de referencia que se encuentra en el
grupo 1 , y se valorarán aquellos escritos usando la herramienta TEX / L A TEX.

\subsection{Recursos}
Usaremos el programa GXemul [1] para simular el entorno de desarrollo que
utilizaremos en este y otros trabajos prácticos, una máquina MIPS corriendo
una versión reciente del sistema operativo NetBSD [2].
En la clase del 21/8 hemos repasado los pasos necesarios para la instalación
y configuración del entorno de desarrollo.

\subsection{Programa}
Se trata de escribir, en lenguaje C, un programa para codificar y decodificar
información en formato base 64: el programa recibirá, por lı́nea de comando,
los archivos o streams de entrada y salida, y la acción a realizar, codificar (ac-
ción por defecto) o decodificar. De no recibir los nombres de los archivos (o
en caso de recibir - como nombre de archivo) usaremos los streams estándar,
stdin y stdout, según corresponda. A continuación, iremos leyendo los datos
de la entrada, generando la salida correspondiente. De ocurrir errores, usare-
mos stderr. Una vez agotados los datos de entrada, el programa debe finalizar
adecuadamente, retornando al sistema operativo.
Estrictamente hablando, base 64 es un grupo de esquemas de codificación
similares. En nuestra implementación, estaremos siguiendo particularmente el
esquema establecido en [3], con el siguiente agregado: si se recibe una secuencia
de caracteres inválida en la decodificación, debe asumirse como una condición
de error que el programa deberá reportar adecuadamente y detener el procesa-
miento en ese punto.

\subsection{Informe}
El informe deberá incluir al menos las siguientes secciones:
Documentación relevante al diseño e implementación del programa;
Comando(s) para compilar el programa;
Las corridas de prueba, con los comentarios pertinentes;
El código fuente, en lenguaje C, el cual también deberá entregarse en
formato digital compilable (incluyendo archivos de entrada y salida de
pruebas);
El código MIPS32 generado por el compilador;
Este enunciado.
El informe deberá entregarse en formato impreso y digital.

\subsection{Referencias}
[1] GXemul, http://gavare.se/gxemul/.
[2] The NetBSD project, http://www.netbsd.org/.
[3] RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One: For-
mat of Internet Message Bodies; sección 6.8, Base64 Content-Transfer-
Encoding. http://tools.ietf.org/html/rfc2045#section-6.8.
[4] Base64 (Wikipedia). http://en.wikipedia.org/wiki/Base64.

\section{Documentación del diseño e implementación}
El programa cuenta con una sección de menú manipulable por el usuario (entre otras cosas) y con otra sección que contiene el código de codificación y decodificación.

\subsection{Menú (main.c)}
En el apartado main.c se puede ver la implementación de un menú, también se observa una tabla correspondiente a la base 64 la cual iremos usando a medida que trabajemos con los codificadores y decodificadores.

El menú posee una opción que ejecuta el programa en modo información "-h" que detalla las variantes de ejecución del programa, estas son -V que imprime la versión del programa y sale del mismo y otra es [options] que muestra las opciones disponibles; estas son -V, -h, -i que está disponible para indicar en donde se encuentra la dirección del archivo de entrada, -o lo mismo pero para el archivo de salida, -a que indica la acción que queremos que ejecute el programa, por default será encode y si quisiéramos que decodifique solo hace falta agregarle un decode.

Si se especifica la opción de codificar o decodificar entonces se podrá también especificar el archivo de entrada y de salida, se le podrá pasar un archivo especifico llamando a la función o también podrá pasárselo desde consola (Stdin y Stdout).

\subsection{Codificación}
La codificación se hace posible con la agrupación de casos que conforman la solución, para esto se dividen los bytes en bits y se agrupan dependiendo la llegada de los mismos; a cada caso le corresponde un respectiva máscara, un respectivo delta de desplazamiento, y los bits faltantes para completar con el signo "=" . Los casos están ordenados, entonces con un bucle se irá codificando a medida, salvo que haya algún carácter invalido, la codificación será exitosa. Esta codificación, agarra el caso y sus parámetros, busca en la tabla de base 64 y traduce los bits en el carácter correspondiente.

\subsection{Decodificación}
Para la decodificación se crea una tabla de decodificación correspondiente, con esta se podrán traducir los caracteres a decodificar. Se tendrá en cuenta los caracteres inválidos, como por ejemplo un "=" entre medio de caracteres de la tabla "base 64".
La decodificación se hará de a bloques de 4 caracteres.

\section{Código pruebas }
#! /bin/sh

touch /tmp/zero.txt #creamos un archivo de texto vacio
./tp0 -a encode -i /tmp/zero.txt -o /tmp/zero.txt.b64
ls -l /tmp/zero.txt.b64
#-rw-r--r-- 1 user group 0 2018-09-08 16:21 /tmp/zero.txt.b64

echo -n M | ./tp0 #codificamos caracter ASCII M
#TQ==
echo

echo -n Ma | ./tp0 #codificamos caracter ASCII M y a
#TWE=
echo



echo -n "Man" | ./tp0 #codificamos Man
#TWFu
echo
echo Man | ./tp0 | ./tp0 -a decode #codificamos y decodificamos
#Man
echo
echo xyz | ./tp0 | ./tp0 -a decode | od -t c #verificamos bit a bit
#0000000 x y z \n
#0000004
echo
yes | head -c 1024 | ./tp0 -a encode #codificamos 1024 bytes, comprobamos longitud
#eQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkK
#...
#eQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5CnkKeQp5Cg==
echo

yes | head -c 1024 | ./tp0 -a encode | ./tp0 -a decode | wc -c #verificamos que los bytes sean 1024
#1024
echo

#Generamos archivos de tamaño creciente
#cat /dev/zero | ./tp0 -a encode

n=1;
while :; do

head -c $n </dev/urandom >/tmp/in.bin;

./tp0 -a encode -i /tmp/in.bin -o /tmp/out.b64;

./tp0 -a decode -i /tmp/out.b64 -o /tmp/out.bin;

if diff /tmp/in.bin /tmp/out.bin; then :; else

echo ERROR: $n;

break;

fi

echo ok: $n;

n=$(($n+1));

rm -f /tmp/in.bin /tmp/out.b64 /tmp/out.bin
done

\section{Código en C}

\end{document}


